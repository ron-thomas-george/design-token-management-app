import axios from 'axios'

class GitHubService {
  constructor(config) {
    this.config = config
    this.api = axios.create({
      baseURL: 'https://api.github.com',
      headers: {
        'Authorization': `token ${config.token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      }
    })
  }

  async verifyConnection() {
    try {
      const response = await this.api.get(`/repos/${this.config.owner}/${this.config.repo}`)
      return { success: true, data: response.data }
    } catch (error) {
      throw new Error(`GitHub verification failed: ${error.response?.data?.message || error.message}`)
    }
  }

  async getDefaultBranch() {
    try {
      const response = await this.api.get(`/repos/${this.config.owner}/${this.config.repo}`)
      return response.data.default_branch
    } catch (error) {
      throw new Error(`Failed to get default branch: ${error.response?.data?.message || error.message}`)
    }
  }

  async createBranch(branchName, baseBranch) {
    try {
      // Get the SHA of the base branch
      const baseRef = await this.api.get(`/repos/${this.config.owner}/${this.config.repo}/git/ref/heads/${baseBranch}`)
      const baseSha = baseRef.data.object.sha

      // Create new branch
      await this.api.post(`/repos/${this.config.owner}/${this.config.repo}/git/refs`, {
        ref: `refs/heads/${branchName}`,
        sha: baseSha
      })

      return { success: true, branch: branchName }
    } catch (error) {
      if (error.response?.status === 422) {
        // Branch already exists
        return { success: true, branch: branchName, existed: true }
      }
      throw new Error(`Failed to create branch: ${error.response?.data?.message || error.message}`)
    }
  }

  async getFileContent(path, branch = null) {
    try {
      const targetBranch = branch || this.config.branch
      const response = await this.api.get(`/repos/${this.config.owner}/${this.config.repo}/contents/${path}`, {
        params: { ref: targetBranch }
      })
      return {
        content: JSON.parse(atob(response.data.content)),
        sha: response.data.sha
      }
    } catch (error) {
      if (error.response?.status === 404) {
        return { content: null, sha: null }
      }
      throw new Error(`Failed to get file content: ${error.response?.data?.message || error.message}`)
    }
  }

  async updateFile(path, content, message, sha = null, branch = null) {
    try {
      const targetBranch = branch || this.config.branch
      const payload = {
        message,
        content: btoa(JSON.stringify(content, null, 2)),
        branch: targetBranch
      }

      if (sha) {
        payload.sha = sha
      }

      console.log('Updating file:', path, 'on branch:', targetBranch)
      console.log('Payload size:', JSON.stringify(payload).length, 'bytes')

      const response = await this.api.put(`/repos/${this.config.owner}/${this.config.repo}/contents/${path}`, payload)
      return { success: true, data: response.data }
    } catch (error) {
      console.error('GitHub API error details:', {
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        message: error.message
      })
      throw new Error(`Failed to update file: ${error.response?.data?.message || error.message}`)
    }
  }

  async createPullRequest(title, body, headBranch, baseBranch) {
    try {
      const response = await this.api.post(`/repos/${this.config.owner}/${this.config.repo}/pulls`, {
        title,
        body,
        head: headBranch,
        base: baseBranch
      })
      return { success: true, data: response.data }
    } catch (error) {
      throw new Error(`Failed to create pull request: ${error.response?.data?.message || error.message}`)
    }
  }

  formatTokensForGitHub(tokens) {
    const tokensByType = tokens.reduce((acc, token) => {
      if (!acc[token.type]) acc[token.type] = {}
      acc[token.type][token.name] = {
        value: token.value,
        description: token.description || '',
        type: token.type
      }
      return acc
    }, {})

    return {
      tokens: tokensByType,
      metadata: {
        version: '1.0.0',
        lastUpdated: new Date().toISOString(),
        totalTokens: tokens.length
      }
    }
  }

  generateCommitMessage(tokens, action = 'update') {
    const tokenCount = tokens.length
    const tokenTypes = [...new Set(tokens.map(t => t.type))]
    
    let message = `${action === 'update' ? 'Update' : 'Add'} design tokens`
    
    if (tokenCount === 1) {
      message += `: ${tokens[0].name}`
    } else {
      message += ` (${tokenCount} tokens)`
    }
    
    if (tokenTypes.length <= 3) {
      message += `\n\nTypes: ${tokenTypes.join(', ')}`
    }
    
    message += '\n\nGenerated by Token Management System'
    
    return message
  }

  generatePullRequestBody(tokens) {
    const tokensByType = tokens.reduce((acc, token) => {
      if (!acc[token.type]) acc[token.type] = []
      acc[token.type].push(token)
      return acc
    }, {})

    let body = '## Design Token Updates\n\n'
    body += `This PR updates ${tokens.length} design token${tokens.length !== 1 ? 's' : ''} in the design system.\n\n`
    
    for (const [type, typeTokens] of Object.entries(tokensByType)) {
      body += `### ${type.charAt(0).toUpperCase() + type.slice(1)} Tokens (${typeTokens.length})\n\n`
      
      for (const token of typeTokens) {
        body += `- **${token.name}**: \`${token.value}\``
        if (token.description) {
          body += ` - ${token.description}`
        }
        body += '\n'
      }
      body += '\n'
    }
    
    body += '---\n'
    body += '*Generated automatically by Token Management System*'
    
    return body
  }
}

export const pushTokensToGitHub = async (tokens, config) => {
  const github = new GitHubService(config)
  
  try {
    // Verify connection first
    await github.verifyConnection()
    
    const defaultBranch = await github.getDefaultBranch()
    const targetBranch = config.branch || defaultBranch
    const shouldCreatePR = targetBranch !== defaultBranch
    
    let workingBranch = targetBranch
    
    // If we need to create a PR, create a feature branch
    if (shouldCreatePR) {
      const timestamp = Date.now()
      workingBranch = `tokens-update-${timestamp}`
      await github.createBranch(workingBranch, defaultBranch)
    }
    
    // Format tokens for GitHub
    const formattedTokens = github.formatTokensForGitHub(tokens)
    
    // Get existing file content (if any)
    const filePath = 'tokens.json'
    const existingFile = await github.getFileContent(filePath, workingBranch)
    
    let updatedContent = formattedTokens
    
    // If file exists, merge with existing tokens
    if (existingFile.content) {
      const existingTokens = existingFile.content.tokens || {}
      
      // Merge tokens by type
      for (const [type, typeTokens] of Object.entries(formattedTokens.tokens)) {
        if (!existingTokens[type]) {
          existingTokens[type] = {}
        }
        Object.assign(existingTokens[type], typeTokens)
      }
      
      updatedContent = {
        tokens: existingTokens,
        metadata: formattedTokens.metadata
      }
    }
    
    // Update the file
    const commitMessage = github.generateCommitMessage(tokens)
    await github.updateFile(filePath, updatedContent, commitMessage, existingFile.sha, workingBranch)
    
    let pullRequest = null
    
    // Create pull request if needed
    if (shouldCreatePR) {
      const prTitle = `Update design tokens (${tokens.length} token${tokens.length !== 1 ? 's' : ''})`
      const prBody = github.generatePullRequestBody(tokens)
      
      pullRequest = await github.createPullRequest(prTitle, prBody, workingBranch, defaultBranch)
    }
    
    return {
      success: true,
      branch: workingBranch,
      pullRequest: pullRequest?.data || null,
      tokensCount: tokens.length
    }
    
  } catch (error) {
    console.error('GitHub push error:', error)
    throw error
  }
}

export default GitHubService
